
from rich.console import Console
import re
import json
import os
from datetime import datetime
import zipfile

console = Console()

def export_markdown(content):
    import datetime
    try:
        filename = f"red_team_plan_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        with open(filename, "w") as f:
            f.write(content)
        console.print(f"[bold green]Plan successfully exported to:[/bold green] {filename}")
    except Exception as e:
        console.print(f"[bold red]Error exporting markdown file:[/bold red] {e}")


def extract_ttps_from_text(text: str):
    """
    Extracts MITRE ATT&CK technique IDs (Txxxx format) from text.
    Optionally captures associated technique names if present.
    Returns a list of dicts with 'tech_id' and 'name'.
    """
    pattern = r"(T\d{4}(?:\.\d{3})?)\s*(?:‚Äì|-)?\s*([^\n]*)"
    matches = re.findall(pattern, text)

    ttps = {}
    for tech_id, name in matches:
        if tech_id not in ttps:
            ttps[tech_id] = name.strip()

    return [{"tech_id": tid, "name": name} for tid, name in ttps.items()]


def save_ttps(ttps: list, base_filename: str, directory="missions"):
    """
    Saves extracted TTPs into a JSON file next to the original mission.
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{base_filename}_ttps_{timestamp}.json"
    path = os.path.join(directory, filename)

    with open(path, "w", encoding="utf-8") as f:
        json.dump(ttps, f, indent=4)

    return path

def export_attack_navigator_layer(ttps: list, base_filename: str, directory="missions", name="Red Team Scenario"):
    """
    Exports a MITRE ATT&CK Navigator layer JSON file using extracted TTPs.
    """
    layer = {
        "version": "4.2",
        "name": name,
        "domain": "enterprise-attack",
        "description": f"Auto-generated layer for {name}",
        "techniques": [
            {
                "techniqueID": t["tech_id"].split(".")[0],
                "score": 1,
                "comment": t["name"]
            } for t in ttps
        ],
        "gradient": {
            "colors": ["#ffffff", "#66ccff"],
            "minValue": 0,
            "maxValue": 1
        },
        "legendItems": [
            {"label": "Technique used in scenario", "color": "#66ccff"}
        ],
        "metadata": [],
        "filters": {"stages": ["act"]},
        "layout": {"layout": "side"},
        "sorting": 0,
        "hideDisabled": False,
        "selectTechniquesAcrossTactics": True
    }

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{base_filename}_navigator_{timestamp}.json"
    path = os.path.join(directory, filename)

    with open(path, "w", encoding="utf-8") as f:
        json.dump(layer, f, indent=4)

    return path


def extract_sigma_rules(text: str):
    """
    Extracts all YAML-formatted Sigma rules from the text after each 'Detection Strategy' header.
    Returns a list of tuples (rule_name, rule_content).
    """
    pattern = r"### üõ°Ô∏è Detection Strategy:\s*```yaml\n(.*?)```"
    matches = re.findall(pattern, text, re.DOTALL)

    sigma_rules = []
    for i, match in enumerate(matches, 1):
        rule_name = f"sigma_rule_{i}"
        sigma_rules.append((rule_name, match.strip()))

    return sigma_rules


def save_sigma_rules(rules: list, base_filename="mission", directory="missions/sigma"):
    """
    Saves each Sigma rule to an individual .yml file.
    Returns list of saved file paths.
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_dir = os.path.join(directory, f"{base_filename}_{timestamp}")
    os.makedirs(output_dir, exist_ok=True)

    file_paths = []

    for name, content in rules:
        file_path = os.path.join(output_dir, f"{name}.yml")
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        file_paths.append(file_path)

    return output_dir, file_paths


def generate_readme(mission_dir: str, metadata: dict = None):
    """
    Generates a README.md file explaining all artifacts in a mission directory.
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    content = f"""# üìò Red Team Scenario ‚Äì Generated by PCYBOX

**Generated on:** {timestamp}

## üìÇ Files in this package:

- `mission.md` ‚Äì Full red team scenario in Markdown
- `mission_ttps_*.json` ‚Äì Extracted MITRE ATT&CK techniques (with metadata)
- `mission_navigator_*.json` ‚Äì ATT&CK Navigator-compatible JSON layer
- `sigma/` ‚Äì Directory containing YAML Sigma rules per step
- `mission_artifacts.zip` ‚Äì Zipped version of the full package

## Purpose

This package is designed to support both **red team operations** (execution) and **blue team engineering** (detections).

Use it for:
- Red team simulations
- Blue team detection rule generation
- Purple teaming / training labs

"""

    if metadata:
        content += f"\n---\n## Mission Summary\n"
        for k, v in metadata.items():
            content += f"- **{k.replace('_', ' ').capitalize()}:** {v}\n"

    readme_path = os.path.join(mission_dir, "README.md")
    with open(readme_path, "w", encoding="utf-8") as f:
        f.write(content)

    return readme_path


def zip_directory(folder_path, output_zip_path):
    """
    Zips the entire contents of a folder into a zip archive.
    """
    with zipfile.ZipFile(output_zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(folder_path):
            for file in files:
                full_path = os.path.join(root, file)
                rel_path = os.path.relpath(full_path, start=folder_path)
                zipf.write(full_path, arcname=rel_path)

    return output_zip_path
